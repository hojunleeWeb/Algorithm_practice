let fs = require("fs");
let input = fs
    .readFileSync("/dev/stdin")
    .toString()
    .split("\n")
    .map((e) => Number(e));

let n = Number(input[0]);
let chairs = input.slice(1);
chairs.unshift(0);
//계단은 한 번에 한 계단씩 또는 두 계단씩 오를 수 있다. 즉, 한 계단을 밟으면서 이어서 다음 계단이나, 다음 다음 계단으로 오를 수 있다.
//연속된 세 개의 계단을 모두 밟아서는 안 된다. 단, 시작점은 계단에 포함되지 않는다.
//마지막 도착 계단은 반드시 밟아야 한다.
//각 계단에 쓰여 있는 점수가 주어질때 얻을 수 있는 총 점수의 최댓값을 구하는 프로그램을 작성하시오.

//-> 계단이 3칸만 있다 가정하자. 그럼 비교해야하는 경우는 꼭대기에서 2칸전 계단을 밟는 경우와 꼭대기 바로전 계단을 밟는 경우로 나뉠수 있다.
//N(x)를 x칸에서의 최대 합 수라고 한다면 N(x) = N(x-1) > N(x-2) ? N(x-1) : N(x-2)가 된다. -> 이 공식대로라면 N(x-1)의 경우에서
//만약 N(x-1)의 최대값이 x-2번째 계단을 타고오는 경우라면 N(x)는 N(x-1)을 고려해서는 안된다.
//N(x)의 값을 저장하는 배열을 만들어 현재 저장된 계단수만큼 배열에 값을 넣으면서 값을 찾을 수 있다.

//2번째 방식 -> N(x) = (c(x-1)+N(x-3)) > (c(x-2)+N(x-3)) ? 전자 : 후자
//x층을 밟는 경우를 x-1층을 밟을 경우 x-2를 밟지 못하게 하고 x-2층을 밟을 경우 x-3층을 밟아도 되게 한다.
//이것도 실패 -> 왜? -> N(x)의 최대값이 반드시 N(x-3)을 포함한다고 보장할수 없음, x-2층 <- x-4층 <-... 도 가능하다.

//3번째 방식 -> N(x) =c(x) + (N(x-2) > c(x-1) + N(x-3)...) -> 정답
let result = new Array(n + 1);
result[0] = 0;
result[1] = chairs[1];
result[2] = chairs[2] + result[1];
for (let i = 3; i <= n; i++) {
    result[i] = chairs[i] + (result[i - 2] > chairs[i - 1] + result[i - 3] ? result[i - 2] : chairs[i - 1] + result[i - 3]);
}
console.log(result[n]);

//해결법 : 계단의 규칙을 잘 세웠어야했다.
//x-1층을 걸었을경우 무조건 x-3층을 밟아야하므로 그떄까지의 최대값을 합하면 된다는것을 빨리 생각해내야했다.
//점화식 모두 x층을 꼭대기로 삼을 경우 x층을 무조건 밟을 경우를 고려하기 떄문에 2번째 경우의 c(x-2) + N(x-3)의 경우에서도
//N(x-3)의 최대값 구성이 x-4층 포함하고 있다면 그또한 존재할 수 없는 구성이였다.
