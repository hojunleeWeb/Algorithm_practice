let fs = require("fs");
let input = fs
    .readFileSync("test.txt")
    .toString()
    .split("\n")
    .map((e) => e.split(" ").map((E) => Number(E)));

//수열 a에서 가장 긴 증가하는 부분 수열을 찾아라
//점화식 생각 -> N(x)를 인덱스 x까지에서 가장 긴 수열의 길이라고 가정하면
//N(x) = N(x-1) + v(x) or N(x-1)
//의문 : x-1까지의 최대 수열 길이를 구성하는 수열과 다른 수열이 x가 추가되었을때 생성될 수 있는가
//x-1까지의 최대 수열을 pn이라하고 x가 추가되었을때의 다른 최대 수열은 kn이라하면
//v(x-1) > v(x)일때 N(kn) >= N(pn)인 수열이 등장할 수 있는가? 만약 그런 수열이 있다고 가정해보자
//v(x-1) > v(x)일때 v(x)가 kn을 구성하는 최대값이 되므로 이미 v(x-1)이 등장했기에 kn에는 v(x-1)이 포함될수 밖에 없다. 따라서
//v(x-1) < v(x)라 하면 모르겠다...

//longest increasing subsequence
//해결법 1 : d(x)를 v(x)를 마지막 값으로 가지는 증가 수열의 길이라고 정의하면
//v(x)가 증가 수열의 마지막 값이 되기 위해선 그 전 증가 수열의 마지막 값보다 v(x)가 커야한다.
//즉 자신 v(x)가 마지막값으로 사용될 수 있는 v(k)값을 찾고 그 중에서 d(k)값이 가장 큰 값에 +1을 하여 d(x)로 사용한다.
//v(x) = 10 20 10 15 20 30이라 하면
//d(x) = 1  2  1  2  3   4 가 되어 값은 4가 된다. -> 중점 : v(x)가 추가될 수 있는 배열을 찾을 수 있도록 d(x)를 정의해놓아야한다.
//최대 길이라고 정의할 경우 v(k)가 무조건 d(k)에 마지막 값인지 아닌지 알 수 없기 때문에 v(k)를 무조건 포함하는 경우로 d(k)를 정의한다.
//시간복잡도  :O(n^2)

//해결법 2 : d(x)를 계산하기 위해서 d(0) ~ d(x-1)을 모두 살펴봐야하는가?
//핵심 개념 : v(x)를 증가 수열에 추가하기 위한 조건은 무엇인가? -> 증가 수열의 최대값보다 v(x)가 커야한다. 또다른 방식으론 나보다 작은 값을 몇개가 있는가?
//증가 수열의 길이마다의 최소값 v'(x)을 저장하면서 d(x)를 채워넣는다면 우리는 v'(x)보다 v(x)가 큰 경우에서 가장 d(x)가 큰 값을 찾아 1을 더한 값이 d(X)가 된다.
//또한 v'(x)보다 v(x)가 작다면 보다 유리한 증가 수열의 구성을 위해 v'(x) 대신 v(x)를 넣는 수열을 구성할 수 있으므로 v'(x)의 값을 v(x)로 대체해야한다.

// v = 10 20 8 15 20 30가 있다고 할때 d'과 v'배열을 유지한다.
// i = 0일떄 v[0] = 10이고 d[0] = 1이므로 d'[0] = 1이고 v'[0] = 10이 된다.
// i = 1일때 v[1] = 20이고 우리는 d'과 v'을 탐색한다. v'[0] = 10이므로 v[1]이 더 크기 때문에 [10,20] 이라는 증가 수열을 만들 수 있으므로 d'[1] = 2로 한후 v'[1] = 20이 된다.
// i = 2일떄 v[2] = 8이고 우리는 d'과 v'을 탐색한다. v'[0] = 8이므로 v[2]보다 더 크게 된다. 우리는 보다 유리한 증가 수열을 만들기 위해(위에 9와 같은 숫자가 등장할 경우를 대비해)
// d'[0] 일때의 증가수열의 최소값을 10에서 8로 업데이트 한다.(증가수열은 앞값이 뒷값보다 작기만 하면 된다. 즉 우리는 각 수열 길이에서 작은 값들을 유지하는 것이다.)

//참고 : https://namu.wiki/w/%EC%B5%9C%EC%9E%A5%20%EC%A6%9D%EA%B0%80%20%EB%B6%80%EB%B6%84%20%EC%88%98%EC%97%B4#s-3.2
